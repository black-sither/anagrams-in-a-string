# anograms-in-a-string
This is my C++ solution to find the count of the anagrams in a string.

We can break the problem into two sub-problems
- Compute all the substrings generated by the given string
- For each substring compare each character and their count
  - if the characters and their counts are same then the substrings are said to be anagrams of each other


We will be using the `map` and `set` containers as they have log(n) time complexity for insert and find operations.

We create a map `allsub` which stores the characters and their counts as a map inside a set container. its key value is the the length of the substring for which we are storing the character counts.

We iterate through all possible substrings which are generated using the `substr()` function. 

`sub=s.substr(i,j);`
 
For each substring we store the character counts in a `map<char,int>` which we named `let`in our code,  we then check if the same map exists in the set of substring maps having the same substring length i.e map <int, **``set< map<char,int> >``** >

with `if(allsub[j].find(let) !=allsub[j].end())` where `j` is the substring length 

- if the same map exists(We got an anagram!)
  - we perform `all_counts[let]++` where `all_counts` is a  `map< map<char,int>,int >` which stores the count of substrings with the same characters in equal numbers(i.e Anangrams) against their character count map, 
  
  **why we do this is explained later down below.. :)**

- if it does not exist
  - we insert the variable `let` to the `set` within `allsub` against it's length value (`j` in my code)  `allsub[j].insert(let)`

So finally we end up with a map `all_counts` containing the anagram character count map and the number of their occurances.

Now, for the explanation that was promised above..

Our objective here is to find the total number of anagram pairs and so far we have found the total number of anagrams.
this can be explained using the below example:

- for the sting **kkkk** there are three types of anagrams:
 - **[k,k]** with **k** occuring at the position 0,1,2 and 3. so,it occurs 4 times
    but we end up with 6 pairs with the following positions of k **[0,1]**,**[0,2]**,**[0,3]**,**[1,2]**,**[1,3]** and **[2,3]**
 - **[kk,kk]** with **kk** occuring at positions [0,1],[1,2] and [2,3] hence, occuring 3 times
    which leads us to the 3 pairs 
    
    **[[0,1],[1,2]]** , **[[0,1],[2,3]]** and  **[[1,2],[2,3]]**
 -  **[kkk,kkk]** which is present at position ***[0,1,2]*** and ***[1,2,3]***
 
     forming the anagram pair [**[0,1,2]**,**[1,2,3]**].


So we are actually counting the number of pairs formed by the anagrams here instead of just the number of anagrams.

the number of pairs given n nodes is given by **n(n-1)/2**

Hence for the final answere we iterate through the `all_counts` values and increment our number of anagrams by

**n(n-1)/2**, where n=all_counts[]->second


**Note that we increase the value of `all_counts[]->second` by 1 as initially its value is only incremented when the same character map already exists in the set inside allsub**

## The complete code is given here:
```cpp
#include <bits/stdc++.h>

using namespace std;

int sherlockAndAnagrams(string s) {
 map <int, set< map<char,int> > > allsub;
 map<char,int> let;
 map< map<char,int>,int > all_counts;
 int anog=0,tmp;
 string sub;
  for(int i=0;i<s.length();i++){
     for(int j=1;j<=s.length() - i;j++){
        let.clear();
        sub=s.substr(i,j);
        for(string::iterator it=sub.begin();it!=sub.end();it++)
        {
            let[*it]+=1;
        }
        if(allsub[j].find(let) !=allsub[j].end())
        {
            all_counts[let]++;
        }
        else
        {
            allsub[j].insert(let);
        }
     }
 }
 for(auto it=all_counts.begin();it!=all_counts.end();it++)
    {
        tmp=it->second + 1;
        if(tmp == 1)
        {
            anog++;
        }
        else
        {
            anog += (tmp * (tmp - 1))/2;
        }
    }
    return anog;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int q;
    cin >> q;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int q_itr = 0; q_itr < q; q_itr++) {
        string s;
        getline(cin, s);

        int result = sherlockAndAnagrams(s);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}
```
